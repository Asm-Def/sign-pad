/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Signpad"] = factory();
	else
		root["Signpad"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/signpad.ts":
/*!************************!*\
  !*** ./src/signpad.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SmoothSignature {\n  constructor(_canvas, options) {\n    _defineProperty(this, \"canvas\", {});\n\n    _defineProperty(this, \"ctx\", {});\n\n    _defineProperty(this, \"width\", 320);\n\n    _defineProperty(this, \"height\", 160);\n\n    _defineProperty(this, \"scale\", window.devicePixelRatio || 1);\n\n    _defineProperty(this, \"color\", 'black');\n\n    _defineProperty(this, \"bgColor\", '');\n\n    _defineProperty(this, \"canDraw\", false);\n\n    _defineProperty(this, \"openSmooth\", true);\n\n    _defineProperty(this, \"minWidth\", 2);\n\n    _defineProperty(this, \"maxWidth\", 6);\n\n    _defineProperty(this, \"minSpeed\", 1.5);\n\n    _defineProperty(this, \"maxWidthDiffRate\", 20);\n\n    _defineProperty(this, \"points\", []);\n\n    _defineProperty(this, \"canAddHistory\", true);\n\n    _defineProperty(this, \"historyList\", []);\n\n    _defineProperty(this, \"maxHistoryLength\", 20);\n\n    _defineProperty(this, \"onStart\", () => {});\n\n    _defineProperty(this, \"onEnd\", () => {});\n\n    _defineProperty(this, \"addListener\", () => {\n      this.removeListener();\n      this.canvas.style.touchAction = 'none';\n\n      if ('ontouchstart' in window || navigator.maxTouchPoints) {\n        this.canvas.addEventListener('touchstart', this.onDrawStart);\n        this.canvas.addEventListener('touchmove', this.onDrawMove);\n        document.addEventListener('touchcancel', this.onDrawEnd);\n        document.addEventListener('touchend', this.onDrawEnd);\n      } else {\n        this.canvas.addEventListener('mousedown', this.onDrawStart);\n        this.canvas.addEventListener('mousemove', this.onDrawMove);\n        document.addEventListener('mouseup', this.onDrawEnd);\n      }\n    });\n\n    _defineProperty(this, \"removeListener\", () => {\n      this.canvas.style.touchAction = 'auto';\n      this.canvas.removeEventListener('touchstart', this.onDrawStart);\n      this.canvas.removeEventListener('touchmove', this.onDrawMove);\n      document.removeEventListener('touchend', this.onDrawEnd);\n      document.removeEventListener('touchcancel', this.onDrawEnd);\n      this.canvas.removeEventListener('mousedown', this.onDrawStart);\n      this.canvas.removeEventListener('mousemove', this.onDrawMove);\n      document.removeEventListener('mouseup', this.onDrawEnd);\n    });\n\n    _defineProperty(this, \"onDrawStart\", e => {\n      e.preventDefault();\n      this.canDraw = true;\n      this.canAddHistory = true;\n      this.ctx.strokeStyle = this.color;\n      this.initPoint(e);\n      this.onStart && this.onStart(e);\n    });\n\n    _defineProperty(this, \"onDrawMove\", e => {\n      e.preventDefault();\n      if (!this.canDraw) return;\n      this.initPoint(e);\n      if (this.points.length < 2) return;\n      this.addHistory();\n      const point = this.points.slice(-1)[0];\n      const prePoint = this.points.slice(-2, -1)[0];\n\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(() => this.onDraw(prePoint, point));\n      } else {\n        this.onDraw(prePoint, point);\n      }\n    });\n\n    _defineProperty(this, \"onDraw\", (prePoint, point) => {\n      if (this.openSmooth) {\n        this.drawSmoothLine(prePoint, point);\n      } else {\n        this.drawNoSmoothLine(prePoint, point);\n      }\n    });\n\n    _defineProperty(this, \"onDrawEnd\", e => {\n      if (!this.canDraw) return;\n      this.canDraw = false;\n      this.canAddHistory = true;\n      this.points = [];\n      this.onEnd && this.onEnd(e);\n    });\n\n    _defineProperty(this, \"getLineWidth\", speed => {\n      const minSpeed = this.minSpeed > 10 ? 10 : this.minSpeed < 1 ? 1 : this.minSpeed;\n      const addWidth = (this.maxWidth - this.minWidth) * speed / minSpeed;\n      const lineWidth = Math.max(this.maxWidth - addWidth, this.minWidth);\n      return Math.min(lineWidth, this.maxWidth);\n    });\n\n    _defineProperty(this, \"getRadianData\", (x1, y1, x2, y2) => {\n      const dis_x = x2 - x1;\n      const dis_y = y2 - y1;\n\n      if (dis_x === 0) {\n        return {\n          val: 0,\n          pos: -1\n        };\n      }\n\n      if (dis_y === 0) {\n        return {\n          val: 0,\n          pos: 1\n        };\n      }\n\n      const val = Math.abs(Math.atan(dis_y / dis_x));\n\n      if (x2 > x1 && y2 < y1 || x2 < x1 && y2 > y1) {\n        return {\n          val,\n          pos: 1\n        };\n      }\n\n      return {\n        val,\n        pos: -1\n      };\n    });\n\n    _defineProperty(this, \"getRadianPoints\", (radianData, x, y, halfLineWidth) => {\n      if (radianData.val === 0) {\n        if (radianData.pos === 1) {\n          return [{\n            x,\n            y: y + halfLineWidth\n          }, {\n            x,\n            y: y - halfLineWidth\n          }];\n        }\n\n        return [{\n          y,\n          x: x + halfLineWidth\n        }, {\n          y,\n          x: x - halfLineWidth\n        }];\n      }\n\n      const dis_x = Math.sin(radianData.val) * halfLineWidth;\n      const dis_y = Math.cos(radianData.val) * halfLineWidth;\n\n      if (radianData.pos === 1) {\n        return [{\n          x: x + dis_x,\n          y: y + dis_y\n        }, {\n          x: x - dis_x,\n          y: y - dis_y\n        }];\n      }\n\n      return [{\n        x: x + dis_x,\n        y: y - dis_y\n      }, {\n        x: x - dis_x,\n        y: y + dis_y\n      }];\n    });\n\n    _defineProperty(this, \"initPoint\", event => {\n      const t = Date.now();\n      const prePoint = this.points.slice(-1)[0];\n\n      if (prePoint && prePoint.t === t) {\n        return;\n      }\n\n      const rect = this.canvas.getBoundingClientRect();\n      const e = event.touches && event.touches[0] || event;\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      if (prePoint && prePoint.x === x && prePoint.y === y) {\n        return;\n      }\n\n      const point = {\n        x,\n        y,\n        t\n      };\n\n      if (this.openSmooth && prePoint) {\n        const prePoint2 = this.points.slice(-2, -1)[0];\n        point.distance = Math.sqrt(Math.pow(point.x - prePoint.x, 2) + Math.pow(point.y - prePoint.y, 2));\n        point.speed = point.distance / (point.t - prePoint.t || 0.1);\n        point.lineWidth = this.getLineWidth(point.speed);\n\n        if (prePoint2 && prePoint2.lineWidth && prePoint.lineWidth) {\n          const rate = (point.lineWidth - prePoint.lineWidth) / prePoint.lineWidth;\n          let maxRate = this.maxWidthDiffRate / 100;\n          maxRate = maxRate > 1 ? 1 : maxRate < 0.01 ? 0.01 : maxRate;\n\n          if (Math.abs(rate) > maxRate) {\n            const per = rate > 0 ? maxRate : -maxRate;\n            point.lineWidth = prePoint.lineWidth * (1 + per);\n          }\n        }\n      }\n\n      this.points.push(point);\n      this.points = this.points.slice(-3);\n    });\n\n    _defineProperty(this, \"drawSmoothLine\", (prePoint, point) => {\n      const dis_x = point.x - prePoint.x;\n      const dis_y = point.y - prePoint.y;\n\n      if (Math.abs(dis_x) + Math.abs(dis_y) <= this.scale) {\n        point.lastX1 = point.lastX2 = prePoint.x + dis_x * 0.5;\n        point.lastY1 = point.lastY2 = prePoint.y + dis_y * 0.5;\n      } else {\n        point.lastX1 = prePoint.x + dis_x * 0.3;\n        point.lastY1 = prePoint.y + dis_y * 0.3;\n        point.lastX2 = prePoint.x + dis_x * 0.7;\n        point.lastY2 = prePoint.y + dis_y * 0.7;\n      }\n\n      point.perLineWidth = (prePoint.lineWidth + point.lineWidth) / 2;\n\n      if (typeof prePoint.lastX1 === 'number') {\n        this.drawCurveLine(prePoint.lastX2, prePoint.lastY2, prePoint.x, prePoint.y, point.lastX1, point.lastY1, point.perLineWidth);\n        if (prePoint.isFirstPoint) return;\n        if (prePoint.lastX1 === prePoint.lastX2 && prePoint.lastY1 === prePoint.lastY2) return;\n        const data = this.getRadianData(prePoint.lastX1, prePoint.lastY1, prePoint.lastX2, prePoint.lastY2);\n        const points1 = this.getRadianPoints(data, prePoint.lastX1, prePoint.lastY1, prePoint.perLineWidth / 2);\n        const points2 = this.getRadianPoints(data, prePoint.lastX2, prePoint.lastY2, point.perLineWidth / 2);\n        this.drawTrapezoid(points1[0], points2[0], points2[1], points1[1]);\n      } else {\n        point.isFirstPoint = true;\n      }\n    });\n\n    _defineProperty(this, \"drawNoSmoothLine\", (prePoint, point) => {\n      point.lastX = prePoint.x + (point.x - prePoint.x) * 0.5;\n      point.lastY = prePoint.y + (point.y - prePoint.y) * 0.5;\n\n      if (typeof prePoint.lastX === 'number') {\n        this.drawCurveLine(prePoint.lastX, prePoint.lastY, prePoint.x, prePoint.y, point.lastX, point.lastY, this.maxWidth);\n      }\n    });\n\n    _defineProperty(this, \"drawCurveLine\", (x1, y1, x2, y2, x3, y3, lineWidth) => {\n      this.ctx.lineWidth = Number(lineWidth.toFixed(1));\n      this.ctx.beginPath();\n      this.ctx.moveTo(Number(x1.toFixed(1)), Number(y1.toFixed(1)));\n      this.ctx.quadraticCurveTo(Number(x2.toFixed(1)), Number(y2.toFixed(1)), Number(x3.toFixed(1)), Number(y3.toFixed(1)));\n      this.ctx.stroke();\n    });\n\n    _defineProperty(this, \"drawTrapezoid\", (point1, point2, point3, point4) => {\n      this.ctx.beginPath();\n      this.ctx.moveTo(Number(point1.x.toFixed(1)), Number(point1.y.toFixed(1)));\n      this.ctx.lineTo(Number(point2.x.toFixed(1)), Number(point2.y.toFixed(1)));\n      this.ctx.lineTo(Number(point3.x.toFixed(1)), Number(point3.y.toFixed(1)));\n      this.ctx.lineTo(Number(point4.x.toFixed(1)), Number(point4.y.toFixed(1)));\n      this.ctx.fillStyle = this.color;\n      this.ctx.fill();\n    });\n\n    _defineProperty(this, \"drawBgColor\", () => {\n      if (!this.bgColor) return;\n      this.ctx.fillStyle = this.bgColor;\n      this.ctx.fillRect(0, 0, this.width, this.height);\n    });\n\n    _defineProperty(this, \"drawByImageUrl\", url => {\n      const image = new Image();\n\n      image.onload = () => {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.ctx.drawImage(image, 0, 0, this.width, this.height);\n      };\n\n      image.crossOrigin = 'anonymous';\n      image.src = url;\n    });\n\n    _defineProperty(this, \"addHistory\", () => {\n      if (!this.maxHistoryLength || !this.canAddHistory) return;\n      this.canAddHistory = false;\n      this.historyList.push(this.canvas.toDataURL());\n      this.historyList = this.historyList.slice(-this.maxHistoryLength);\n    });\n\n    _defineProperty(this, \"clear\", () => {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n      this.drawBgColor();\n      this.historyList.length = 0;\n    });\n\n    _defineProperty(this, \"undo\", () => {\n      const dataUrl = this.historyList.splice(-1)[0];\n      dataUrl && this.drawByImageUrl(dataUrl);\n    });\n\n    _defineProperty(this, \"toDataURL\", (type = 'image/png', quality = 1) => {\n      if (this.canvas.width === this.width) {\n        return this.canvas.toDataURL(type, quality);\n      }\n\n      const canvas = document.createElement('canvas');\n      canvas.width = this.width;\n      canvas.height = this.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(this.canvas, 0, 0, canvas.width, canvas.height);\n      return canvas.toDataURL(type, quality);\n    });\n\n    _defineProperty(this, \"getPNG\", () => {\n      return this.toDataURL();\n    });\n\n    _defineProperty(this, \"getJPG\", (quality = 0.8) => {\n      return this.toDataURL('image/jpeg', quality);\n    });\n\n    _defineProperty(this, \"isEmpty\", () => {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.width = this.canvas.width;\n      canvas.height = this.canvas.height;\n\n      if (this.bgColor) {\n        ctx.fillStyle = this.bgColor;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      } else if (this.scale !== 1) {\n        ctx.scale(this.scale, this.scale);\n      }\n\n      return canvas.toDataURL() === this.canvas.toDataURL();\n    });\n\n    _defineProperty(this, \"getRotateCanvas\", (degree = 90) => {\n      if (degree > 0) {\n        degree = degree > 90 ? 180 : 90;\n      } else {\n        degree = degree < -90 ? 180 : -90;\n      }\n\n      const canvas = document.createElement('canvas');\n      const w = this.width;\n      const h = this.height;\n\n      if (degree === 180) {\n        canvas.width = w;\n        canvas.height = h;\n      } else {\n        canvas.width = h;\n        canvas.height = w;\n      }\n\n      const ctx = canvas.getContext('2d');\n      ctx.rotate(degree * Math.PI / 180);\n\n      if (degree === 90) {\n        // 顺时针90度\n        ctx.drawImage(this.canvas, 0, -h, w, h);\n      } else if (degree === -90) {\n        // 逆时针90度\n        ctx.drawImage(this.canvas, -w, 0, w, h);\n      } else if (degree === 180) {\n        ctx.drawImage(this.canvas, -w, -h, w, h);\n      }\n\n      return canvas;\n    });\n\n    this.init(_canvas, options);\n  }\n\n  init(canvas, options = {}) {\n    if (!canvas) return;\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.width = options.width || canvas.clientWidth || this.width;\n    this.height = options.height || canvas.clientHeight || this.height;\n    this.scale = options.scale || this.scale;\n    this.color = options.color || this.color;\n    this.bgColor = options.bgColor || this.bgColor;\n    this.openSmooth = options.openSmooth || this.openSmooth;\n    this.minWidth = options.minWidth || this.minWidth;\n    this.maxWidth = options.maxWidth || this.maxWidth;\n    this.minSpeed = options.minSpeed || this.minSpeed;\n    this.maxWidthDiffRate = options.maxWidthDiffRate || this.maxWidthDiffRate;\n    this.maxHistoryLength = options.maxHistoryLength || this.maxHistoryLength;\n    this.onStart = options.onStart;\n    this.onEnd = options.onEnd;\n\n    if (this.scale > 0) {\n      this.canvas.height = this.height * this.scale;\n      this.canvas.width = this.width * this.scale;\n\n      if (this.scale !== 1) {\n        this.canvas.style.width = this.width + 'px';\n        this.canvas.style.height = this.height + 'px';\n        this.ctx.scale(this.scale, this.scale);\n      }\n    }\n\n    this.ctx.lineCap = 'round';\n    this.drawBgColor();\n    this.addListener();\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SmoothSignature);\n\n//# sourceURL=webpack://Signpad/./src/signpad.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/signpad.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});